default namespace local = "tag:textalign.net,2015:ns"

start =
    
    ## specifies that the file is a div-based TAN alignment file. Root element.
    element TAN-A-div { TAN-root }
include "incl/TAN-class-2.rnc" {
    
    ## TAN-A-div files must have one or more sources
    source-list = source-item+
    
    ## TAN-A-div sources must be named
    source-id-opt = internal-id
    
    ## no levels of certainty are allowed in TAN-A-div files; substitute is strength-claim
    certainty-stamp = ed-stamp?
    
    ## TAN-A-div files may not point to individual characters/glyphs
    char-ref = empty
    
    ## TAN-A-div files do not require a tokenization choice within a filter (choice enforced by Schematron)
    decl-token-opt = decl-tok-def*
    
    ## This statement also does away with groups in TAN-A-div files
    TAN-body-core = work-equiv*, div-type-equiv*, split*, realignment*, alignment*
    
    ## alignments may take either an id with no supplementary variables or else no id and optional variables indicating strength, exclusivity, distribution, and auto-alignment
    alignment-attributes-non-class-2 = strength-claim?, distribute-claim?
    
    ## alignments must contain either one or more div-refs or a list of IDREFS to other alignments
    alignment-content-non-class-2 =
        (div-ref-item-for-source
         | div-ref-group-for-source
         | div-ref-item-for-work
         | div-ref-group-for-work)*
    decl-non-class-2 = decl-topics*
    non-class-2-opt = topic-opt?
    
    ## alignments suppres @cert in <tok> (used only to split leaf divs)
    cert-opt = empty
}
decl-topics =
    
    ## declares one or more topics, to be used in conjunction with @topic under <align> to associate alignments with specific topics instead of verbatim parallels.  
    element topic {
        ed-stamp?,
        (inclusion
         | (internal-id, (comment* & entity-nondigital-ref)))
    }
topic-opt =
    
    ## points to one or more topics to which an alignment should be associated. If this attribute is not present, it is assumed that the alignment links different versions of roughly the same text.
    
    ## TAN does not stipluate what can be inferred via @topic. If ref A is aligned with B via topic x, and B with C via topic y, no guarantee is made as to what relationship A has to C. 
    attribute topic { text }
work-equiv =
    
    ## declares an ad hoc equivalence between works that are not defined by their sources as being identical.
    
    ## Any two <work>s that share at least one <IRI> value will be treated as equivalent; those that do not will be treated as different div types. <equate-works> permits you to make an ad hoc equivalence between one or more <work>s.
    
    ## <equate-div-types> are assumed to be greedy and transitive. If this element is used to equate work X with type Y, then any any source with a work identical to X's or Y's IRI values will treated as identical.
    ## If work X of source A is stated to be equivalent to work Y of source B, then any work in any source identical to X will be identical to any work in any source identical to Y. So to equate two works, each with multiple members, you need declare the equivalence between only one member of each work, not all of them.
    
    ## This element does not imply that the two works are, in reality, one and the same. It merely states that, for the purposes of this alignment, they should be treated as equivalent.
    element equate-works { ed-stamp?, (inclusion | work-refs) }
div-type-equiv =
    
    ## declares an ad hoc equivalence between div types that are not defined by their sources as being identical.
    
    ## Any two <div-type>s that share at least one <IRI> value will be treated as equivalent; those that do not will be treated as different div types. <equate-div-types> permits you to make an ad hoc equivalence between one or more <div-type-ref>s.
    
    ## <equate-div-types> are assumed to be greedy and transitive. If this element is used to equate div type X with type Y, then any div type in any source identical to X's or Y's IRI values will treated as identical. 
    
    ## This element does not imply that the two types of division are, in reality, one and the same. It merely states that, for the purposes of this alignment, they should be treated as equivalent.
    element equate-div-types {
        ed-stamp?,
        (inclusion | (div-type-ref-cluster, div-type-ref-cluster+))
    }
div-type-ref-cluster =
    
    ## points to a <div-type> in one or more sources, using the @xml:id assigned by the source to that div type. 
    element div-type-ref { ed-stamp?, source-ref, div-type-ref }
split =
    
    ## creates ad hoc splits in leaf <div>s, to facilitate alignments and realignments of textual units smaller than leaf <div>s. Any leaf div may be split as many times as there are token, as defined by <tokenization>s.
    
    ## Each split creates a segment, a textual subdivision of leaf <div>s introduced by the TAN-A-div file.
    element split-leaf-div-at {
        ed-stamp?,
        (inclusion | (comment* & tok-regular+))
    }
strength-claim =
    
    ## tempers the strength of an alignment. Suitable for alignments you would wish to differentiate, such as verbatim parallels from indirect references. This attribute does not imply doubt, uncertainty, or the reason for strengthening or weakening the alignment. If you need to specify exactly what concept of text reuse attaches to an alignment, you should use TAN-A-tok and <tok> with @reuse-type and @cert.
    
    ## This attribute takes an arbitrary rational decimal number from 0 to 1 indicating how strong the alignment should be. No specific meaning is to be assigned to this attribute. Interpretation of these values is processor-dependent.  
    
    ## This attribute is inheritable. See main.xml#inheritable_attributes
    attribute strength {
        xsd:string { pattern = "0\.\d+" }
    }
realignment =
    
    ## corrects misaligned or unaligned divisions and segments in versions of the same work. This element (1) exempts any divs or segments referred to in children <div-ref>s from their default alignments and (2) realigns them together as a group. Realignments have two types.
    
    ## An UNANCHORED realigment is useful for divisions that need to be removed from any automatic alignment. It consists solely of one or more <div-ref>s. The effect is (1) to sever each referenced <div> from any automatic alignment and (2) to realign each source's nth reference (div or segment) with the nth reference in every other other source, if any, invoked in the <realign>. If only one source is invoked in a <realign>, only the first effect takes place: the references are effectively severed from any automatic alignment with any other version for that source. Realignment is inherited, affecting not only the specified <div>s but their descendants too.
    
    ## An ANCHORED realignment is useful for making sure a minority of misplaced <div>s align with the majority. It begins with a single <anchor-div-ref> as the first child of <realign>, then one or more <div-ref>s. The effect is (1) to sever each referenced <div> from any automatic alignment and (2) to realign each source's nth reference (div or segment) with the nth reference in the anchor. If <anchor-div-ref> points to only one reference then all subsequent <div-ref>s will be tethered collectively to that one anchor reference.
    
    ## Unanchored <realign>s effectively sever every <div-ref> from any automatic alignment. But anchored ones do not sever automatic alignment; they merely shift it to the anchor. This method is helpful for synchronizing a few sources with the reference system followed by the majority.
    
    ## Because of the distributive nature of the realignment, every value of @ref that involves a hyphen must have siblings with balanced depth on the left and right side of the hyphen (i.e., ref="1 - 2.1" would be invalid).
    
    ## This element is source-specific and not subject to any transitive properties. The assertions apply only to the specific sources that are cited.
    
    ## If @seg is used, every @ref must point to a leaf <div>, and @seg must point to a valid segment defined by <split-leaf-div-at>.
    
    ## For both anchored and unanchored alignments alike, the order of <div-ref>s is immaterial.
    element realign {
        ed-stamp?,
        (inclusion
         | (distribute-claim?,
            (comment*
             & ((anchor-div-ref-item | anchor-div-ref-group)?,
                (div-ref-item-for-source | div-ref-group-for-source)*))))
    }
# exclusive-claim =

#    attribute exclusive {
#       xsd:boolean { pattern = "true|1" }
#  }

## indicates whether an alignment should be treated as non-transitive or transitive. If there is no @exclusive, then if X is aligned with Y, then anything that aligns with X will align with anything that aligns with Y. If @exclusive is present then the alignment holds only between the specified references. The latter is useful, e.g., for specifying cases where one version of a work uniquely quotes from another. Value must be 1 or true, implied by the very presence of the attribute. If you wish to decare it to be false, delete the attribute altogether.
distribute-claim =
    
    ## indicates whether values should be matched one-to-one, or grouped. 
    
    ## If this attribute is not present (= default / false()), then each set of references in a single <div-ref> will be treated as a set and aligned against every other <div-ref> set. 
    
    ## If @distribute is present (= true()), then every nth ref in every set (defined by a single <div-ref>, taking into account any continuations defined by @cont) will be aligned with the nth ref in every other set. Therefore the number of references derived from @refs must be identical.
    
    ## If @distribute is true() then any ranges in @ref will be resolved shallowly, e.g., ref="2 b - 4" would be resolved something like ("2 b", "2  c", "3", "4"), even if there are further subdivisions of "3" and "4".
    
    ## Value must be 1 or true, implied by the very presence of the attribute. If you wish to decare it to be false, delete the attribute altogether.
    attribute distribute {
        xsd:boolean { pattern = "true|1" }
    }
# <div-ref> and <anchor-div-ref> 
anchor-div-ref-item =
    
    ## defines a <div> to which other <div>s in other versions of the same work should be realigned (via <div-ref>s that follow). The first child of a <realign>, it is constructed exactly like <div-ref>, except that the mandatory @src may point only to a single source. 
    
    ## <anchor-div-ref> is always followed by one or more <div-ref>s. 
    
    ## If <anchor-div-ref> points to only one reference (i.e., @src, @ref, and @seg [if present] each have only one value) then however many references are made in subsequent <div-ref>s, they will all be realigned to that one anchor reference. 
    
    ## But if <anchor-div-ref> has more than one reference, then distribution is in effect. Every nth reference will be the anchor for the nth reference in subsequent <div-ref>s (grouped by source).
    element anchor-div-ref { div-ref-attr-core, work-ref }
anchor-div-ref-group =
    element anchor-div-ref { div-ref-attr-core, work-ref, continuation },
    element anchor-div-ref { div-ref-attr-core, continuation }*,
    element anchor-div-ref { div-ref-attr-core }
div-ref-item-for-work = element div-ref { div-ref-attr-core, strength-claim?, work-ref }
div-ref-group-for-work =
    
    ## collects one or more <div>s (or segments of <div>s) in one or more sources
    
    ## In most cases, the texts pointed to in <div-ref> will be treated as a collective set. If passage A is found three times in X, Y, and Z, then in an <align> four different <div-ref>s should be used. But if A is found once, spanning X, Y, and Z, then the last three should be gathered in a single <div-ref>, or, optionally, in a <div-ref> with a @cont.
    element div-ref { div-ref-attr-core, strength-claim?, work-ref, continuation },
    div-ref-group-continuation
div-ref-item-for-source = element div-ref { div-ref-attr-core, strength-claim?, source-ref }
div-ref-group-for-source =
    element div-ref { div-ref-attr-core, strength-claim?, source-ref, continuation },
    div-ref-group-continuation
div-ref-group-continuation =
    element div-ref { div-ref-attr-core, continuation }*,
    element div-ref { div-ref-attr-core }
div-ref-attr-core = ed-stamp?, pointer-to-div-range, seg-ref?
seg-ref =
    
    ## picks specific segments in a leaf div (and only to leaf divs). There must be an appropriate number of splits declared for those leaf divs in <split-leaf-div-at>.
    attribute seg { seq-picker }
work-ref =
    
    ## refers to a work by means of a source ID as a proxy. 
    attribute work {
        xsd:string { pattern = "\S+" }
    }
work-refs =
    
    ## refers to works by means of source IDs as a proxy. 
    attribute work { text }
# detritus
# div-ref-item = div-ref-regular | div-ref-sequence
# div-ref-regular = element div-ref { div-ref-attr-regular }
# div-ref-sequence =
#    div-ref-with-src-and-cont, div-ref-with-cont-but-no-src*, div-ref-without-cont-or-src
# div-ref-with-src-and-cont = element div-ref { div-ref-attr-with-src-and-cont }
# div-ref-with-cont-but-no-src = element div-ref { div-ref-attr-with-cont-but-no-src }
# div-ref-without-cont-or-src = element div-ref { div-ref-attr-without-cont-or-src }
# div-ref-attr-regular = div-ref-attr-core, source-ref, strength-claim?
# div-ref-attr-with-src-and-cont = div-ref-attr-core, source-ref, continuation, strength-claim?
# div-ref-attr-with-cont-but-no-src = div-ref-attr-core, continuation
# div-ref-attr-without-cont-or-src = div-ref-attr-core
